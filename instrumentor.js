// Generated by CoffeeScript 1.3.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice;

  define(['graph', 'underscore'], function(Graph, _) {
    var Instrumentor;
    _.isConstructor = function(thing) {
      if (thing.name && thing.name[0].toUpperCase() === thing.name[0]) {
        return true;
      } else {
        return false;
      }
    };
    Instrumentor = (function() {

      function Instrumentor(namespace) {
        this.instrumentObject = __bind(this.instrumentObject, this);

        this.instrumentFunction = __bind(this.instrumentFunction, this);

        this.instrumentConstructor = __bind(this.instrumentConstructor, this);

        this.trigger = __bind(this.trigger, this);

        this.addNode = __bind(this.addNode, this);
        this.dontInstrument = ['constructor', '_configure', 'make', 'initialize', 'delegateEvents', 'undelegateEvents', 'setElement'];
        this.nodes = [];
        this.links = [];
        this.instrument(namespace);
      }

      Instrumentor.prototype.addLink = function(from, to) {
        return this.links.push({
          source: from.id,
          target: to.id,
          value: 1
        });
      };

      Instrumentor.prototype.nextNodeId = function() {
        if (this.nodes.length === 0) {
          return 0;
        } else {
          return _(this.nodes).last().id + 1;
        }
      };

      Instrumentor.prototype.addNode = function(name, type, parent) {
        var node;
        if (parent == null) {
          parent = null;
        }
        node = {
          id: this.nextNodeId(),
          name: name,
          group: type
        };
        this.nodes.push(node);
        if (parent) {
          this.addLink(parent, node);
        }
        if (this.graph && this.graph.rendered) {
          this.graph.updateNodes(this.nodes, this.links);
        }
        return node;
      };

      Instrumentor.prototype.trigger = function(node) {
        this.graph.triggerNode(node);
        return console.log('triggered', node);
      };

      Instrumentor.prototype.instrument = function(namespace) {
        this.instrumentObject(null, 'Root', namespace);
        return this.graph = new Graph(this.nodes, this.links).render();
      };

      Instrumentor.prototype.instrumentConstructor = function(parentNode, cons) {
        var addNode, instrumentObject, newCons, node, trigger;
        node = this.addNode(cons.name, 'function', parentNode);
        trigger = this.trigger;
        addNode = this.addNode;
        instrumentObject = this.instrumentObject;
        newCons = function() {
          var args, o;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          o = cons.apply(this, args);
          trigger(node);
          return o;
        };
        newCons.prototype = this.instrumentObject(node, cons.name, cons.prototype);
        return newCons;
      };

      Instrumentor.prototype.instrumentFunction = function(parentNode, name, func) {
        var node, trigger;
        node = this.addNode(name, 'function', parentNode);
        trigger = this.trigger;
        return function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          trigger(node);
          console.log("Calling", name);
          return func.apply.apply(func, [this].concat(__slice.call(args)));
        };
      };

      Instrumentor.prototype.instrumentObject = function(parentNode, name, object) {
        var key, node, val, _fn,
          _this = this;
        node = this.addNode(name || 'Anon', 'object', parentNode);
        _fn = function(key, val) {
          if ((object.hasOwnProperty(key)) || (object.__proto__.hasOwnProperty(key))) {
            if (!(_(_this.dontInstrument).include(key) || key[0] === '_')) {
              if (_.isFunction(val)) {
                if (_.isConstructor(val)) {
                  return object[key] = _this.instrumentConstructor(node, val);
                } else {
                  return object[key] = _this.instrumentFunction(node, key, val);
                }
              } else if (_.isObject(val)) {
                return object[key] = _this.instrumentObject(node, key, val);
              }
            }
          }
        };
        for (key in object) {
          val = object[key];
          _fn(key, val);
        }
        return object;
      };

      return Instrumentor;

    })();
    return Instrumentor;
  });

}).call(this);
